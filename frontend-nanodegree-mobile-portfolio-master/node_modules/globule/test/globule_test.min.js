var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.findInternal=function(a,b,c){a instanceof String&&(a=String(a));for(var d=a.length,e=0;e<d;e++){var f=a[e];if(b.call(c,f,e,a))return{i:e,v:f}}return{i:-1,v:void 0}};$jscomp.ASSUME_ES5=!1;$jscomp.ASSUME_NO_NATIVE_MAP=!1;$jscomp.ASSUME_NO_NATIVE_SET=!1;$jscomp.defineProperty=$jscomp.ASSUME_ES5||"function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,c){a!=Array.prototype&&a!=Object.prototype&&(a[b]=c.value)};
$jscomp.getGlobal=function(a){return"undefined"!=typeof window&&window===a?a:"undefined"!=typeof global&&null!=global?global:a};$jscomp.global=$jscomp.getGlobal(this);$jscomp.polyfill=function(a,b,c,d){if(b){c=$jscomp.global;a=a.split(".");for(d=0;d<a.length-1;d++){var e=a[d];e in c||(c[e]={});c=c[e]}a=a[a.length-1];d=c[a];b=b(d);b!=d&&null!=b&&$jscomp.defineProperty(c,a,{configurable:!0,writable:!0,value:b})}};
$jscomp.polyfill("Array.prototype.find",function(a){return a?a:function(a,c){return $jscomp.findInternal(this,a,c).v}},"es6-impl","es3");var path=require("path"),globule=require("../lib/globule.js");
exports.match={"empty set":function(a){a.expect(6);a.deepEqual(globule.match(null,"foo.js"),[],"should return empty set.");a.deepEqual(globule.match("*.js",null),[],"should return empty set.");a.deepEqual(globule.match([],"foo.js"),[],"should return empty set.");a.deepEqual(globule.match("*.js",[]),[],"should return empty set.");a.deepEqual(globule.match(null,["foo.js"]),[],"should return empty set.");a.deepEqual(globule.match(["*.js"],null),[],"should return empty set.");a.done()},"basic matching":function(a){a.expect(6);
a.deepEqual(globule.match("*.js","foo.js"),["foo.js"],"should match correctly.");a.deepEqual(globule.match("*.js",["foo.js"]),["foo.js"],"should match correctly.");a.deepEqual(globule.match("*.js",["foo.js","bar.css"]),["foo.js"],"should match correctly.");a.deepEqual(globule.match(["*.js","*.css"],"foo.js"),["foo.js"],"should match correctly.");a.deepEqual(globule.match(["*.js","*.css"],["foo.js"]),["foo.js"],"should match correctly.");a.deepEqual(globule.match(["*.js","*.css"],["foo.js","bar.css"]),
["foo.js","bar.css"],"should match correctly.");a.done()},"no matches":function(a){a.expect(2);a.deepEqual(globule.match("*.js","foo.css"),[],"should fail to match.");a.deepEqual(globule.match("*.js",["foo.css","bar.css"]),[],"should fail to match.");a.done()},unique:function(a){a.expect(2);a.deepEqual(globule.match("*.js",["foo.js","foo.js"]),["foo.js"],"should return a uniqued set.");a.deepEqual(globule.match(["*.js","*.*"],["foo.js","foo.js"]),["foo.js"],"should return a uniqued set.");a.done()},
flatten:function(a){a.expect(1);a.deepEqual(globule.match([["*.js","*.css"],["*.*","*.js"]],["foo.js","bar.css"]),["foo.js","bar.css"],"should process nested pattern arrays correctly.");a.done()},exclusion:function(a){a.expect(5);a.deepEqual(globule.match(["!*.js"],["foo.js","bar.js"]),[],"solitary exclusion should match nothing");a.deepEqual(globule.match(["*.js","!*.js"],["foo.js","bar.js"]),[],"exclusion should cancel match");a.deepEqual(globule.match(["*.js","!f*.js"],["foo.js","bar.js","baz.js"]),
["bar.js","baz.js"],"partial exclusion should partially cancel match");a.deepEqual(globule.match(["*.js","!*.js","b*.js"],["foo.js","bar.js","baz.js"]),["bar.js","baz.js"],"inclusion / exclusion order matters");a.deepEqual(globule.match(["*.js","!f*.js","*.js"],["foo.js","bar.js","baz.js"]),["bar.js","baz.js","foo.js"],"inclusion / exclusion order matters");a.done()},"options.matchBase":function(a){a.expect(2);a.deepEqual(globule.match("*.js",["foo.js","bar","baz/xyz.js"],{matchBase:!0}),["foo.js",
"baz/xyz.js"],"should matchBase (minimatch) when specified.");a.deepEqual(globule.match("*.js",["foo.js","bar","baz/xyz.js"]),["foo.js"],"should not matchBase (minimatch) by default.");a.done()}};
exports.isMatch={"basic matching":function(a){a.expect(6);a.ok(globule.isMatch("*.js","foo.js"),"should match correctly.");a.ok(globule.isMatch("*.js",["foo.js"]),"should match correctly.");a.ok(globule.isMatch("*.js",["foo.js","bar.css"]),"should match correctly.");a.ok(globule.isMatch(["*.js","*.css"],"foo.js"),"should match correctly.");a.ok(globule.isMatch(["*.js","*.css"],["foo.js"]),"should match correctly.");a.ok(globule.isMatch(["*.js","*.css"],["foo.js","bar.css"]),"should match correctly.");
a.done()},"no matches":function(a){a.expect(6);a.ok(!globule.isMatch("*.js","foo.css"),"should fail to match.");a.ok(!globule.isMatch("*.js",["foo.css","bar.css"]),"should fail to match.");a.ok(!globule.isMatch(null,"foo.css"),"should fail to match.");a.ok(!globule.isMatch("*.js",null),"should fail to match.");a.ok(!globule.isMatch([],"foo.css"),"should fail to match.");a.ok(!globule.isMatch("*.js",[]),"should fail to match.");a.done()},"options.matchBase":function(a){a.expect(2);a.ok(globule.isMatch("*.js",
["baz/xyz.js"],{matchBase:!0}),"should matchBase (minimatch) when specified.");a.ok(!globule.isMatch("*.js",["baz/xyz.js"]),"should not matchBase (minimatch) by default.");a.done()}};
exports.find={setUp:function(a){this.cwd=process.cwd();process.chdir("test/fixtures/expand");a()},tearDown:function(a){process.chdir(this.cwd);a()},"basic matching":function(a){a.expect(5);a.deepEqual(globule.find("**/*.js"),["js/bar.js","js/foo.js"],"single pattern argument should match.");a.deepEqual(globule.find("**/*.js","**/*.css"),["js/bar.js","js/foo.js","css/baz.css","css/qux.css"],"multiple pattern arguments should match.");a.deepEqual(globule.find(["**/*.js","**/*.css"]),["js/bar.js","js/foo.js",
"css/baz.css","css/qux.css"],"array of patterns should match.");a.deepEqual(globule.find([["**/*.js"],[["**/*.css","js/*.js"]]]),["js/bar.js","js/foo.js","css/baz.css","css/qux.css"],"array of arrays of patterns should be flattened.");a.deepEqual(globule.find("*.xyz"),[],"bad pattern should fail to match.");a.done()},unique:function(a){a.expect(4);a.deepEqual(globule.find("**/*.js","js/*.js"),["js/bar.js","js/foo.js"],"file list should be uniqed.");a.deepEqual(globule.find("**/*.js","**/*.css","js/*.js"),
["js/bar.js","js/foo.js","css/baz.css","css/qux.css"],"file list should be uniqed.");a.deepEqual(globule.find("js","js/"),["js","js/"],"mixed non-ending-/ and ending-/ dirs will not be uniqed by default.");a.deepEqual(globule.find("js","js/",{mark:!0}),["js/"],'mixed non-ending-/ and ending-/ dirs will be uniqed when "mark" is specified.');a.done()},"file order":function(a){a.expect(5);var b=globule.find("**/*.{js,css}"),c=["css/baz.css","css/qux.css","js/bar.js","js/foo.js"];a.deepEqual(b,c,"should select 4 files in this order, by default.");
b=globule.find("js/foo.js","js/bar.js","**/*.{js,css}");c=["js/foo.js","js/bar.js","css/baz.css","css/qux.css"];a.deepEqual(b,c,"specifically-specified-up-front file order should be maintained.");b=globule.find("js/bar.js","js/foo.js","**/*.{js,css}");c=["js/bar.js","js/foo.js","css/baz.css","css/qux.css"];a.deepEqual(b,c,"specifically-specified-up-front file order should be maintained.");b=globule.find("**/*.{js,css}","!css/qux.css","css/qux.css");c=["css/baz.css","js/bar.js","js/foo.js","css/qux.css"];
a.deepEqual(b,c,"if a file is excluded and then re-added, it should be added at the end.");b=globule.find("js/foo.js","**/*.{js,css}","!css/qux.css","css/qux.css");c=["js/foo.js","css/baz.css","js/bar.js","css/qux.css"];a.deepEqual(b,c,"should be able to combine specified-up-front and excluded/added-at-end.");a.done()},exclusion:function(a){a.expect(8);a.deepEqual(globule.find(["!js/*.js"]),[],"solitary exclusion should match nothing");a.deepEqual(globule.find(["js/bar.js","!js/bar.js"]),[],"exclusion should negate match");
a.deepEqual(globule.find(["**/*.js","!js/foo.js"]),["js/bar.js"],"should omit single file from matched set");a.deepEqual(globule.find(["!js/foo.js","**/*.js"]),["js/bar.js","js/foo.js"],"inclusion / exclusion order matters");a.deepEqual(globule.find(["**/*.js","**/*.css","!js/bar.js","!css/baz.css"]),["js/foo.js","css/qux.css"],"multiple exclusions should be removed from the set");a.deepEqual(globule.find(["**/*.js","**/*.css","!**/*.css"]),["js/bar.js","js/foo.js"],"excluded wildcards should be removed from the matched set");
a.deepEqual(globule.find(["js/bar.js","js/foo.js","css/baz.css","css/qux.css","!**/b*.*"]),["js/foo.js","css/qux.css"],"different pattern for exclusion should still work");a.deepEqual(globule.find(["js/bar.js","!**/b*.*","js/foo.js","css/baz.css","css/qux.css"]),["js/foo.js","css/baz.css","css/qux.css"],"inclusion / exclusion order matters");a.done()},"options.mark":function(a){a.expect(4);a.deepEqual(globule.find("**d*/**"),"deep deep/deep.txt deep/deeper deep/deeper/deeper.txt deep/deeper/deepest deep/deeper/deepest/deepest.txt".split(" "),
"should match files and directories.");a.deepEqual(globule.find("**d*/**/"),["deep/","deep/deeper/","deep/deeper/deepest/"],"trailing / in pattern should match directories only, matches end in /.");a.deepEqual(globule.find("**d*/**",{mark:!0}),"deep/ deep/deep.txt deep/deeper/ deep/deeper/deeper.txt deep/deeper/deepest/ deep/deeper/deepest/deepest.txt".split(" "),'the minimatch "mark" option ensures directories end in /.');a.deepEqual(globule.find("**d*/**/",{mark:!0}),["deep/","deep/deeper/","deep/deeper/deepest/"],
'the minimatch "mark" option should not remove trailing / from matched paths.');a.done()},"options.filter":function(a){a.expect(5);a.deepEqual(globule.find("**d*/**",{filter:"isFile"}),["deep/deep.txt","deep/deeper/deeper.txt","deep/deeper/deepest/deepest.txt"],"should match files only.");a.deepEqual(globule.find("**d*/**",{filter:"isDirectory"}),["deep","deep/deeper","deep/deeper/deepest"],"should match directories only.");a.deepEqual(globule.find("**",{arbitraryProp:/deepest/,filter:function(a,
c){return c.arbitraryProp.test(a)}}),["deep/deeper/deepest","deep/deeper/deepest/deepest.txt"],"should filter arbitrarily.");a.deepEqual(globule.find("js","css",{filter:"isFile"}),[],"should fail to match.");a.deepEqual(globule.find("**/*.js",{filter:"isDirectory"}),[],"should fail to match.");a.done()},"options.matchBase":function(a){a.expect(3);a.deepEqual(globule.find("*.js"),[],"should not matchBase (minimatch) by default.");a.deepEqual(globule.find("*.js",{matchBase:!0}),["js/bar.js","js/foo.js"],
"matchBase option should be passed through to minimatch.");a.deepEqual(globule.find("*.js","*.css",{matchBase:!0}),["js/bar.js","js/foo.js","css/baz.css","css/qux.css"],"matchBase option should be passed through to minimatch.");a.done()},"options.srcBase":function(a){a.expect(5);a.deepEqual(globule.find(["**/deep*.txt"],{srcBase:"deep"}),["deep.txt","deeper/deeper.txt","deeper/deepest/deepest.txt"],"should find paths matching pattern relative to srcBase.");a.deepEqual(globule.find(["**/deep*.txt"],
{cwd:"deep"}),["deep.txt","deeper/deeper.txt","deeper/deepest/deepest.txt"],"cwd and srcBase should do the same thing.");a.deepEqual(globule.find(["**/deep*"],{srcBase:"deep",filter:"isFile"}),["deep.txt","deeper/deeper.txt","deeper/deepest/deepest.txt"],"srcBase should not prevent filtering.");a.deepEqual(globule.find(["**/deep*"],{srcBase:"deep",filter:"isDirectory"}),["deeper","deeper/deepest"],"srcBase should not prevent filtering.");a.deepEqual(globule.find(["**/deep*.txt","!**/deeper**"],{srcBase:"deep"}),
["deep.txt","deeper/deepest/deepest.txt"],"srcBase should not prevent exclusions.");a.done()},"options.prefixBase":function(a){a.expect(2);a.deepEqual(globule.find(["**/deep*.txt"],{srcBase:"deep",prefixBase:!1}),["deep.txt","deeper/deeper.txt","deeper/deepest/deepest.txt"],"should not prefix srcBase to returned paths.");a.deepEqual(globule.find(["**/deep*.txt"],{srcBase:"deep",prefixBase:!0}),["deep/deep.txt","deep/deeper/deeper.txt","deep/deeper/deepest/deepest.txt"],"should prefix srcBase to returned paths.");
a.done()},"options.nonull":function(a){a.expect(3);a.deepEqual(globule.find(["*omg*"],{nonull:!0}),["*omg*"],"non-matching patterns should be returned in result set.");a.deepEqual(globule.find(["js/a*","js/b*","js/c*"],{nonull:!0}),["js/a*","js/bar.js","js/c*"],"non-matching patterns should be returned in result set.");a.deepEqual(globule.find(["js/foo.js","js/bar.js","js/nonexistent.js"],{nonull:!0}),["js/foo.js","js/bar.js","js/nonexistent.js"],"non-matching filenames should be returned in result set.");
a.done()}};
exports.mapping={"basic mapping":function(a){a.expect(1);var b=globule.mapping(["a.txt","b.txt","c.txt"]);a.deepEqual(b,[{dest:"a.txt",src:["a.txt"]},{dest:"b.txt",src:["b.txt"]},{dest:"c.txt",src:["c.txt"]}],"default options should create same-to-same src-dest mappings.");a.done()},"options.srcBase":function(a){a.expect(2);var b=globule.mapping(["a.txt","bar/b.txt","bar/baz/c.txt"],{srcBase:"foo"});var c=[{dest:"a.txt",src:["foo/a.txt"]},{dest:"bar/b.txt",src:["foo/bar/b.txt"]},{dest:"bar/baz/c.txt",src:["foo/bar/baz/c.txt"]}];
a.deepEqual(b,c,"srcBase should be prefixed to src paths (no trailing /).");b=globule.mapping(["a.txt","bar/b.txt","bar/baz/c.txt"],{srcBase:"foo/"});a.deepEqual(b,c,"srcBase should be prefixed to src paths (trailing /).");a.done()},"options.destBase":function(a){a.expect(2);var b=globule.mapping(["a.txt","bar/b.txt","bar/baz/c.txt"],{destBase:"dest"});var c=[{dest:"dest/a.txt",src:["a.txt"]},{dest:"dest/bar/b.txt",src:["bar/b.txt"]},{dest:"dest/bar/baz/c.txt",src:["bar/baz/c.txt"]}];a.deepEqual(b,
c,"destBase should be prefixed to dest paths (no trailing /).");b=globule.mapping(["a.txt","bar/b.txt","bar/baz/c.txt"],{destBase:"dest/"});a.deepEqual(b,c,"destBase should be prefixed to dest paths (trailing /).");a.done()},"options.flatten":function(a){a.expect(1);var b=globule.mapping(["a.txt","bar/b.txt","bar/baz/c.txt"],{flatten:!0});a.deepEqual(b,[{dest:"a.txt",src:["a.txt"]},{dest:"b.txt",src:["bar/b.txt"]},{dest:"c.txt",src:["bar/baz/c.txt"]}],"flatten should remove all src path parts from dest.");
a.done()},"options.flatten + options.destBase":function(a){a.expect(1);var b=globule.mapping(["a.txt","bar/b.txt","bar/baz/c.txt"],{destBase:"dest",flatten:!0});a.deepEqual(b,[{dest:"dest/a.txt",src:["a.txt"]},{dest:"dest/b.txt",src:["bar/b.txt"]},{dest:"dest/c.txt",src:["bar/baz/c.txt"]}],"flatten and destBase should work together.");a.done()},"options.ext":function(a){a.expect(1);var b=globule.mapping(["x/a.js","x.y/b.min.js","x.y/z.z/c"],{ext:".foo"});a.deepEqual(b,[{dest:"x/a.foo",src:["x/a.js"]},
{dest:"x.y/b.foo",src:["x.y/b.min.js"]},{dest:"x.y/z.z/c.foo",src:["x.y/z.z/c"]}],"by default, ext should replace everything after the first dot in the filename.");a.done()},"options.extDot":function(a){a.expect(2);var b=globule.mapping(["x/a.js","x.y/b.bbb.min.js","x.y/z.z/c"],{ext:".foo",extDot:"first"});var c=[{dest:"x/a.foo",src:["x/a.js"]},{dest:"x.y/b.foo",src:["x.y/b.bbb.min.js"]},{dest:"x.y/z.z/c.foo",src:["x.y/z.z/c"]}];a.deepEqual(b,c,'extDot of "first" should replace everything after the first dot in the filename.');
b=globule.mapping(["x/a.js","x.y/b.bbb.min.js","x.y/z.z/c"],{ext:".foo",extDot:"last"});c=[{dest:"x/a.foo",src:["x/a.js"]},{dest:"x.y/b.bbb.min.foo",src:["x.y/b.bbb.min.js"]},{dest:"x.y/z.z/c.foo",src:["x.y/z.z/c"]}];a.deepEqual(b,c,'extDot of "last" should replace everything after the last dot in the filename.');a.done()},"options.rename":function(a){a.expect(1);var b=globule.mapping(["a.txt","bar/b.txt","bar/baz/c.txt"],{arbitraryProp:"FOO",rename:function(a,b){return path.join(b.arbitraryProp,
a.toUpperCase())}});a.deepEqual(b,[{dest:"FOO/A.TXT",src:["a.txt"]},{dest:"FOO/BAR/B.TXT",src:["bar/b.txt"]},{dest:"FOO/BAR/BAZ/C.TXT",src:["bar/baz/c.txt"]}],"allow arbitrary renaming of files.");a.done()}};
exports.findMapping={setUp:function(a){this.cwd=process.cwd();process.chdir("test/fixtures");a()},tearDown:function(a){process.chdir(this.cwd);a()},"basic matching":function(a){a.expect(2);var b=globule.findMapping(["expand/**/*.txt"]),c=[{dest:"expand/deep/deep.txt",src:["expand/deep/deep.txt"]},{dest:"expand/deep/deeper/deeper.txt",src:["expand/deep/deeper/deeper.txt"]},{dest:"expand/deep/deeper/deepest/deepest.txt",src:["expand/deep/deeper/deepest/deepest.txt"]}];a.deepEqual(b,c,"default options");
c=globule.mapping(globule.find(["expand/**/*.txt"]));a.deepEqual(b,c,"this is what it's doing under the hood, anwyays.");a.done()},"options.srcBase":function(a){a.expect(1);var b=globule.findMapping(["**/*.txt"],{destBase:"dest",srcBase:"expand/deep"});a.deepEqual(b,[{dest:"dest/deep.txt",src:["expand/deep/deep.txt"]},{dest:"dest/deeper/deeper.txt",src:["expand/deep/deeper/deeper.txt"]},{dest:"dest/deeper/deepest/deepest.txt",src:["expand/deep/deeper/deepest/deepest.txt"]}],"srcBase should be stripped from front of destPath, pre-destBase+destPath join");
a.done()}};
